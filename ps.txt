css in style == global 
one component --> <style scoped> 限制只在此元件中，上下都不會被汙染
vue add tailwind 
tailwind.config.js 編寫個人CSS
1.open sans定義在index.html
2.tailwind.config.js-theme-extend-fontFamily-sans = open sans + default
<MainNav></MainNav> = <MainNav /> = <main-nav></main-nav> = <main-nav />
jest ---> test/unit/***.test.js
npm run test:unit (define in package.json-script-test:unit)
describe:test name, it:unit name, expect(測試內容).toBe(期待內容)
describe - describe - it 
import 'func name'  from 'js'   export const 'func name' 
TDD -test driven develope test->codings test
vue component test :
1.import {mount} from "@vue/test-utils"
2....  const wrapper = mount(MainNav)
3. wrapper.html()--html  wrapper.text()--輸出資料
4.只須包含、某處有 -- expect(wrapper.text()).toMatch(data)
2-1 const wrapper = mount(MainNav,{data(){}....}) mount第二個參數可丟data取代原vue元件data
    不推，因TDD須以測試為基礎不應另外給予參數
2-2 async()=> { ... await wrapper.setData({company:"Super Corp"})}
第一項額外屬性: tailwind.config.js-variant-extend-margin:["first"](new ver 可不用設定) ---> first:ml-0
v-for test:unit
1.const wrapper ..... Items = wrapper.findAll("li")--> html DOM 
2.Texts = Items.map((item)=>item.text()) --> li內容陣列
3.expect(Texts).toEqual 相似裡面的內容
1-1 Items = wrapper.findAll("[data-test='main-nav-list-item']") 利用屬性來尋找測試目標
1-2 <li v-for... class=.. data-test='main-nav-list-item'> 在物件上增加屬性
login test
1.... const loginButton = wrapper.findComponent({name:"component name"})
2.expect(loginButton.exists()).toBe(true);
1-1 ... const loginButton = wrapper.find("[data-test='login-button']");
1-2 MainNav.vue- <action-button data-test="login-button" /> 避免元件重新命名時找不到
click test
1.async()=>{... await loginButton.trigger("click")} -->trigger() 非同步
2.profileImage = wrapper.find("[data-test='profile-image']");-->重新獲取狀態
props (reuse button in any place)
1. child---> exports default{ props:["text"]}
2. parent ---> <action-button text="Sign in">
.css button{@apply px-5...} ---> use tailwind in html text
html==:is-primary  vue.scripts==isPrimary
html== type="primary" vue.scripts== props:["type"]  ButtonClass(){return [this.type]:true}-->(primary)
type:{validator(value){return ["primary", "secondary"].includes(value)} --->驗證是否只有要求的內容
acionButton--Camel case  action-button--Kebab case
.eslint.js rules:"vue/multi-word-component-names": "off" 避免要求要多字元件
fontawesome
npm install --save @fortawesome/fontawesome-svg-core @fortawesome/free-solid-svg-icons @fortawesome/vue-fontawesome@prerelease
--> 為了在vue中以元件方式讀取
main.js:  libary.import(fasearch)  createApp(App).component("font-awesome-icon", FontAwesomeIcon) --只載入需要的svg
mount-->產生元件後子元件也會產生，造成子元件資料沒輸入會測試失敗 -->shallowMount只產生該元件不要產生所有的子元件
test.js: global:{stubs:{FAI:true} } --> <div>...</div><FAI></FAI> 避免不需要測試的指定子層元件FAI被mount
mainnav shallowmount profileImage不會被測試 -->add profileImage.test.js
hero --> mainpage 內容
header沒有height class ，hero被擋住-->headerClassheight(){h-16, h-32}
.js export default {funcname} --> .vue import {func} from 
test component use fake func --> jest.fn()
jest.useFakeTimers("legacy") --> 取代時間函數setInterval避免時間真的進入，結束後jest.useRealTimer()
jest.runOnlyPendingTimers() --> 進入時間函數但跳過時間
測試下一時間狀態 --> await nextTick() 經過時間後確認vue model data真的被更新
.test.js beforeEach、afterEach 每個測試之前/之後做的事情
input bind: 1.updateRole(event){this.role=event.target.value}  2.@input="updateRole" ;;  @input="location = $event.target.value"
v-model =  "variable name" --> 綁定變數間行為
this.$emit("event name", event value) --> 向上傳遞資料
@event-name="role= $event" --> 在元件中對由子元素接收傳過來的資料($event)做動作
1. parent :value="role" --> 向子元素props變數
2. child props{value} --> 宣告接收子元素
3. child :value="value" -->輸入文字框中雙向綁定傳進來的本地value變數
4. child @input this.$emit("handleInput", $event.target.value) --> 將輸入的資料以handleInput的名字向上去傳遞
5. parent @handle-input="role = $event" -->父元件從handle-input事件中得到值，並將值送入本地role
test for input box ---> 1. const input = screen.getbyrole("textbox") 從螢幕抓取textbox
    2. await userEvent.type(input, "NYC") 模仿輸入NYC的過程 --> 產生 [['N'], ['NY'], ['NYC']] 
    3. const message = emitted()["update:modelValue"] 類似emit update:modelValue
    4. expect(message).toEqual([['N'], ['NY'], ['NYC']]) 

this.$route --- show route information
:to={name:'Home'} === to="/"
as :51  ==> stub:{RouterLink: RouterLinkStub,} 做個router-link的填充物
thesubna.test.js const $route --> 給一個目前route的名稱測試
global:{mocks{$route}} 以自訂物件的方式的方式給全域變數$route內容
route path:"jobs/results/:id" 以url id傳進$route當中 ---> JobView.vue this.$route.params.id來接
form @submit.prevent="method" 避免整頁送出的submit刑式 用提供的method的形式對vue送出router參數跟目標
jobsearchform.test.js 1.push = vi.fn() 模仿一個函數動作給 $router
                2.mocks {$router:$router} 模仿送出後給router的push
                3.screen.getbyrole(元素,名稱) <-- userEvent.type 待輸入後送入
                4.expect(push).toHaveBeenCalled 期望route push後送出的東西包含role跟location中的值
package.js中增加"backend": "json-server --watch  db.json" ::確保npm會在更動時重新仔入
npm run backend --> 啟動json server
 

getbyrole for sync <--> findbyrole for async
personal token:: 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
url :: https://gk1221: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@github.com/gk1221/udemypractice.git









