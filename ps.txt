css in style == global 
one component --> <style scoped> 限制只在此元件中，上下都不會被汙染
vue add tailwind 
tailwind.config.js 編寫個人CSS
1.open sans定義在index.html
2.tailwind.config.js-theme-extend-fontFamily-sans = open sans + default
<MainNav></MainNav> = <MainNav /> = <main-nav></main-nav> = <main-nav />
jest ---> test/unit/***.test.js
npm run test:unit (define in package.json-script-test:unit)
describe:test name, it:unit name, expect(測試內容).toBe(期待內容)
describe - describe - it 
import 'func name'  from 'js'   export const 'func name' 
TDD -test driven develope test->codings test
vue component test :
1.import {mount} from "@vue/test-utils"
2....  const wrapper = mount(MainNav)
3. wrapper.html()--html  wrapper.text()--輸出資料
4.只須包含、某處有 -- expect(wrapper.text()).toMatch(data)
2-1 const wrapper = mount(MainNav,{data(){}....}) mount第二個參數可丟data取代原vue元件data
    不推，因TDD須以測試為基礎不應另外給予參數
2-2 async()=> { ... await wrapper.setData({company:"Super Corp"})}
第一項額外屬性: tailwind.config.js-variant-extend-margin:["first"](new ver 可不用設定) ---> first:ml-0
v-for test:unit
1.const wrapper ..... Items = wrapper.findAll("li")--> html DOM 
2.Texts = Items.map((item)=>item.text()) --> li內容陣列
3.expect(Texts).toEqual 相似裡面的內容
1-1 Items = wrapper.findAll("[data-test='main-nav-list-item']") 利用屬性來尋找測試目標
1-2 <li v-for... class=.. data-test='main-nav-list-item'> 在物件上增加屬性
login test
1.... const loginButton = wrapper.findComponent({name:"component name"})
2.expect(loginButton.exists()).toBe(true);
1-1 ... const loginButton = wrapper.find("[data-test='login-button']");
1-2 MainNav.vue- <action-button data-test="login-button" /> 避免元件重新命名時找不到
click test
1.async()=>{... await loginButton.trigger("click")} -->trigger() 非同步
2.profileImage = wrapper.find("[data-test='profile-image']");-->重新獲取狀態
props (reuse button in any place)
1. child---> exports default{ props:["text"]}
2. parent ---> <action-button text="Sign in">
.css button{@apply px-5...} ---> use tailwind in html text
html==:is-primary  vue.scripts==isPrimary
html== type="primary" vue.scripts== props:["type"]  ButtonClass(){return [this.type]:true}-->(primary)
type:{validator(value){return ["primary", "secondary"].includes(value)} --->驗證是否只有要求的內容
acionButton--Camel case  action-button--Kebab case
.eslint.js rules:"vue/multi-word-component-names": "off" 避免要求要多字元件
fontawesome
npm install --save @fortawesome/fontawesome-svg-core @fortawesome/free-solid-svg-icons @fortawesome/vue-fontawesome@prerelease
--> 為了在vue中以元件方式讀取
main.js:  libary.import(fasearch)  createApp(App).component("font-awesome-icon", FontAwesomeIcon) --只載入需要的svg
mount-->產生元件後子元件也會產生，造成子元件資料沒輸入會測試失敗 -->shallowMount只產生該元件不要產生所有的子元件
test.js: global:{stubs:{FAI:true}} --> <div>...</div><FAI></FAI> 避免不需要測試的指定子層元件FAI被mount
mainnav shallowmount profileImage不會被測試 -->add profileImage.test.js
hero --> mainpage 內容
header沒有height class ，hero被擋住-->headerClassheight(){h-16, h-32}
.js export default {funcname} --> .vue import {func} from 
test component use fake func --> jest.fn()
jest.useFakeTimers("legacy") --> 取代時間函數setInterval避免時間真的進入，結束後jest.useRealTimer()
jest.runOnlyPendingTimers() --> 進入時間函數但跳過時間
測試下一時間狀態 --> await nextTick() 經過時間後確認vue model data真的被更新






